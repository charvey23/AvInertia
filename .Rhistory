m_pred  = m_ell+m_par+m_end
CG_pred = (1/m_true)*(m_ell*CG_ell + m_par*CG_par + m_end*CG_end) # Frame of reference: Torso | Origin: VRP
#also try to minimize the difference between each variable
err_mean = (abs(rho_par-rho_ell) + abs(rho_back-rho_ell) + abs(rho_par-rho_back))/mean(c(x[1],x[2]))
# calculates the summation of the absolute total error of the mass and the CG - need to minimize both
tot_err = abs(m_pred-m_true)/m_true + abs(CG_pred-CG_true)/CG_true + 0.1*err_mean
tot_err
m_pred
CG_pred
density_optimizer <- function(x, w_max, h_max, l_bmax, w_leg, l_leg, CG_true, m_true){
# NOTE: all CG locations only include the position only the length of the body as the z and y axes are symmetrical
rho_ell  = abs(x[1])
rho_par  = abs(x[2])
rho_back = abs(x[3])
h_leg  = w_leg*h_max/w_max
l_par  = (l_leg-l_bmax)
l_full = l_par/(1-(w_leg/w_max))
l_end  = l_tot - l_leg
# hemiellipsoid
m_ell  = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
CG_ell = (5/8)*l_bmax                                   # Frame of reference: Torso | Origin: VRP
# partial elliptic cone
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full) # mass as if the interior cone went to full length
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
m_par  = m_full - m_cut # mass of the partial cone
CG_full = l_bmax+0.25*l_full
CG_cut  = l_bmax+l_par+0.25*(l_full-l_par)
CG_par  = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)     # Frame of reference: Torso | Origin: VRP
# end elliptic cone
m_end   = (1/12)*pi*rho_back*w_leg*h_leg*l_end
CG_end  = l_leg+0.25*l_end                              # Frame of reference: Torso | Origin: VRP
m_pred  = m_ell+m_par+m_end
CG_pred = (1/m_true)*(m_ell*CG_ell + m_par*CG_par + m_end*CG_end) # Frame of reference: Torso | Origin: VRP
#also try to minimize the difference between each variable
err_mean = (abs(rho_par-rho_ell) + abs(rho_back-rho_ell) + abs(rho_par-rho_back))/mean(c(x[1],x[2]))
# calculates the summation of the absolute total error of the mass and the CG - need to minimize both
tot_err = abs(m_pred-m_true)/m_true + abs(CG_pred-CG_true)/CG_true + 0.05*err_mean
return(tot_err)
}
test   = lsqnonlin(density_optimizer, x0, options=list(tolx=1e-12, tolg=1e-12), w_max, h_max, l_bmax, w_leg, l_leg, CG_true, m_true)
# NOTE: all CG locations only include the position only the length of the body as the z and y axes are symmetrical
rho_ell  = abs(test$x[1])
rho_par  = abs(test$x[2])
rho_back = abs(test$x[3])
h_leg  = w_leg*h_max/w_max
l_par  = (l_leg-l_bmax)
l_full = l_par/(1-(w_leg/w_max))
l_end  = l_tot - l_leg
# hemiellipsoid
m_ell  = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
CG_ell = (5/8)*l_bmax                                   # Frame of reference: Torso | Origin: VRP
# partial elliptic cone
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full) # mass as if the interior cone went to full length
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
m_par  = m_full - m_cut # mass of the partial cone
CG_full = l_bmax+0.25*l_full
CG_cut  = l_bmax+l_par+0.25*(l_full-l_par)
CG_par  = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)     # Frame of reference: Torso | Origin: VRP
# end elliptic cone
m_end   = (1/12)*pi*rho_back*w_leg*h_leg*l_end
CG_end  = l_leg+0.25*l_end                              # Frame of reference: Torso | Origin: VRP
m_pred  = m_ell+m_par+m_end
CG_pred = (1/m_true)*(m_ell*CG_ell + m_par*CG_par + m_end*CG_end) # Frame of reference: Torso | Origin: VRP
#also try to minimize the difference between each variable
err_mean = (abs(rho_par-rho_ell) + abs(rho_back-rho_ell) + abs(rho_par-rho_back))/mean(c(x[1],x[2]))
# calculates the summation of the absolute total error of the mass and the CG - need to minimize both
tot_err = abs(m_pred-m_true)/m_true + abs(CG_pred-CG_true)/CG_true + 0.1*err_mean
tot_err
m_pred
CG_pred
err_mean
test$x
x0 = as.matrix(c(800,800,800))
test   = lsqnonlin(density_optimizer, x0, options=list(tolx=1e-12, tolg=1e-12), w_max, h_max, l_bmax, w_leg, l_leg, CG_true, m_true)
test$x
# NOTE: all CG locations only include the position only the length of the body as the z and y axes are symmetrical
rho_ell  = abs(test$x[1])
rho_par  = abs(test$x[2])
rho_back = abs(test$x[3])
h_leg  = w_leg*h_max/w_max
l_par  = (l_leg-l_bmax)
l_full = l_par/(1-(w_leg/w_max))
l_end  = l_tot - l_leg
# hemiellipsoid
m_ell  = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
CG_ell = (5/8)*l_bmax                                   # Frame of reference: Torso | Origin: VRP
# partial elliptic cone
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full) # mass as if the interior cone went to full length
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
m_par  = m_full - m_cut # mass of the partial cone
CG_full = l_bmax+0.25*l_full
CG_cut  = l_bmax+l_par+0.25*(l_full-l_par)
CG_par  = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)     # Frame of reference: Torso | Origin: VRP
# end elliptic cone
m_end   = (1/12)*pi*rho_back*w_leg*h_leg*l_end
CG_end  = l_leg+0.25*l_end                              # Frame of reference: Torso | Origin: VRP
m_pred  = m_ell+m_par+m_end
CG_pred = (1/m_true)*(m_ell*CG_ell + m_par*CG_par + m_end*CG_end) # Frame of reference: Torso | Origin: VRP
#also try to minimize the difference between each variable
err_mean = (abs(rho_par-rho_ell) + abs(rho_back-rho_ell) + abs(rho_par-rho_back))/mean(c(x[1],x[2]))
# calculates the summation of the absolute total error of the mass and the CG - need to minimize both
tot_err = abs(m_pred-m_true)/m_true + abs(CG_pred-CG_true)/CG_true + 0.1*err_mean
m_pred
CG_pred
err_mean
density_optimizer <- function(x, w_max, h_max, l_bmax, w_leg, h_leg, l_leg, l_full, l_par, l_end, CG_true, m_true){
# NOTE: all CG locations only include the position only the length of the body as the z and y axes are symmetrical
rho_ell  = abs(x[1])
rho_par  = abs(x[2])
rho_back = abs(x[3])
# hemiellipsoid
m_ell  = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
CG_ell = (5/8)*l_bmax                                   # Frame of reference: Torso | Origin: VRP
# partial elliptic cone
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full) # mass as if the interior cone went to full length
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
m_par  = m_full - m_cut # mass of the partial cone
CG_full = l_bmax+0.25*l_full
CG_cut  = l_bmax+l_par+0.25*(l_full-l_par)
CG_par  = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)     # Frame of reference: Torso | Origin: VRP
# end elliptic cone
m_end   = (1/12)*pi*rho_back*w_leg*h_leg*l_end
CG_end  = l_leg+0.25*l_end                              # Frame of reference: Torso | Origin: VRP
m_pred  = m_ell+m_par+m_end
CG_pred = (1/m_true)*(m_ell*CG_ell + m_par*CG_par + m_end*CG_end) # Frame of reference: Torso | Origin: VRP
#also try to minimize the difference between each variable
err_mean = (abs(rho_par-rho_ell) + abs(rho_back-rho_ell) + abs(rho_par-rho_back))/mean(c(x[1],x[2]))
# calculates the summation of the absolute total error of the mass and the CG - need to minimize both
tot_err = abs(m_pred-m_true)/m_true + abs(CG_pred-CG_true)/CG_true + 0.05*err_mean
return(tot_err)
}
densities = lsqnonlin(density_optimizer, x0, options=list(tolx=1e-12, tolg=1e-12), w_max, h_max, l_bmax, w_leg, h_leg, l_leg, l_full, l_par, l_end, CG_true, m_true)
densities$x
w_max  = 0.118
h_max  = 0.09
l_bmax = 0.088
w_leg  = 0.098
l_leg  = 0.138
l_tot  = 0.301
CG_true = 0.109
m_true  = 0.87778
# pre-define info about the partial elliptic cone
h_leg  = w_leg*h_max/w_max
l_par  = (l_leg-l_bmax)
l_full = l_par/(1-(w_leg/w_max))
l_end  = l_tot - l_leg
# initial guess for the densities - in the order: emiellipsoid, Partial cone, end cone
x0        = as.matrix(c(800,800,800))
densities = lsqnonlin(density_optimizer, x0, options=list(tolx=1e-12, tolg=1e-12), w_max, h_max, l_bmax, w_leg, h_leg, l_leg, l_full, l_par, l_end, CG_true, m_true)
rho_ell   = abs(densities$x[1])
rho_par   = abs(densities$x[2])
rho_back  = abs(densities$x[3])
# -------------- Hemiellipsoid -------------------
# Determine the mass of the front
m_ell   = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
# MOI about the base
I_ell1  = calc_inertia_ellipse(w_max/2, h_max/2, l_bmax, m_ell)   # Frame of reference: Torso | Origin: Hemiellipsoid base
# Define center of gravity wrt to I origin
CG_ell1 = c(0,0,-(3/8)*l_bmax)                                    # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the hemiellipsoid
I_ellCG = parallelaxis(I_ell1,CG_ell1,m_ell,"A")                  # Frame of reference: Torso | Origin: Hemiellipsoid CG
# Define center of gravity wrt to VRP origin
CG_ell2 = c(0,0,(5/8)*l_bmax)                                     # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_ell_vrp = parallelaxis(I_ellCG,-CG_ell2,m_ell,"CG")             # Frame of reference: Torso | Origin: VRP
# -------------- Partial elliptic cone -------------------
# mass as if the interior cone went to full length
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full)
# mass of the ghost part of the cone
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
# mass of the partial cone
m_par  = m_full - m_cut
# CG as if the interior cone went to full length
CG_full = c(0,0,0.25*l_full)                                      # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the ghost part of the cone
CG_cut  = c(0,0,l_par+0.25*(l_full-l_par))                        # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the partial cone
CG_par1 = c(0,0,(1/m_par)*(m_full*CG_full - m_cut*CG_cut))        # Frame of reference: Torso | Origin: Hemiellipsoid base
# MOI of the partial cone about the wide base
I_par1  = calc_inertia_ellcone(w_max, h_max, l_par, l_full, rho_par)  # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_parCG = parallelaxis(I_par1,CG_par1,m_par,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_par2 = CG_par1 + c(0,0,l_bmax)                                        # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")                    # Frame of reference: Torso | Origin: VRP
# -------------- Full elliptic cone -------------------
# mass of the end cone
m_end  = (1/12)*(pi*rho_back*w_leg*h_leg*l_end)
# CG of the end cone
CG_end1 = c(0,0,0.25*l_end)                               # Frame of reference: Torso | Origin: Base of the end cone
# MOI of the partial cone about the wide base
I_end1  = calc_inertia_ellcone(w_leg, h_leg, l_end, l_end, rho_back)     # Frame of reference: Torso | Origin: Base of the end cone
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_endCG = parallelaxis(I_end1,CG_end1,m_end,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_end2 = CG_end1 + c(0,0,(l_bmax + l_par))                              # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_endCG,-CG_end2,m_end,"CG")                    # Frame of reference: Torso | Origin: VRP
# -------------- Hemiellipsoid -------------------
# Determine the mass of the front
m_ell   = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
# MOI about the base
I_ell1  = calc_inertia_ellipse(w_max/2, h_max/2, l_bmax, m_ell)   # Frame of reference: Torso | Origin: Hemiellipsoid base
# Define center of gravity wrt to I origin
CG_ell1 = c(0,0,-(3/8)*l_bmax)                                    # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the hemiellipsoid
I_ellCG = parallelaxis(I_ell1,CG_ell1,m_ell,"A")                  # Frame of reference: Torso | Origin: Hemiellipsoid CG
# Define center of gravity wrt to VRP origin
CG_ell2 = c(0,0,(5/8)*l_bmax)                                     # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_ell_vrp = parallelaxis(I_ellCG,-CG_ell2,m_ell,"CG")             # Frame of reference: Torso | Origin: VRP
# -------------- Partial elliptic cone -------------------
# mass as if the interior cone went to full length
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full)
# mass of the ghost part of the cone
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
# mass of the partial cone
m_par  = m_full - m_cut
# CG as if the interior cone went to full length
CG_full = c(0,0,0.25*l_full)                                      # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the ghost part of the cone
CG_cut  = c(0,0,l_par+0.25*(l_full-l_par))                        # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the partial cone
CG_par1 = c(0,0,(1/m_par)*(m_full*CG_full - m_cut*CG_cut))        # Frame of reference: Torso | Origin: Hemiellipsoid base
# MOI of the partial cone about the wide base
I_par1  = calc_inertia_ellcone(w_max, h_max, l_par, l_full, rho_par)  # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_parCG = parallelaxis(I_par1,CG_par1,m_par,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_par2 = CG_par1 + c(0,0,l_bmax)                                        # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")                    # Frame of reference: Torso | Origin: VRP
#' @param lf  length of the full cone as if it had not been cut (m)
#' @param rho density of the partial cone (kg/m^3)
#'
#' @author Christina Harvey
#'
#' @return a 3x3 matrix representing the moment of inertia tensor of a partial solid elliptical cone about
#' the center of the wider base with z oriented towards the end
#'
#' @export
#'
calc_inertia_ellcone <- function(w, h, lp, lf, rho){
I = matrix(0, nrow = 3, ncol = 3)
tmpxy = (((lp-lf)^5/lf^4)+lf)
tmpz  = (lp^3/(3*lf^2))*((6*lp^2)-(15*lp*lf)+(10*lf^2))
I[1,1] = rho*w*h*pi*(tmpxy*(w^2/8) + tmpz) # Ixx
I[2,2] = rho*w*h*pi*(tmpxy*(h^2/8) + tmpz) # Iyy
I[3,3] = (1/8)*rho*w*h*pi*tmpxy*(w^2+h^2)  # Izz
I = (1/40)*I
return(I)
}
# mass as if the interior cone went to full length
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full)
# mass of the ghost part of the cone
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
# mass of the partial cone
m_par  = m_full - m_cut
# CG as if the interior cone went to full length
CG_full = c(0,0,0.25*l_full)                                      # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the ghost part of the cone
CG_cut  = c(0,0,l_par+0.25*(l_full-l_par))                        # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the partial cone
CG_par1 = c(0,0,(1/m_par)*(m_full*CG_full - m_cut*CG_cut))        # Frame of reference: Torso | Origin: Hemiellipsoid base
# MOI of the partial cone about the wide base
I_par1  = calc_inertia_ellcone(w_max, h_max, l_par, l_full, rho_par)  # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_parCG = parallelaxis(I_par1,CG_par1,m_par,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_par2 = CG_par1 + c(0,0,l_bmax)                                        # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")                    # Frame of reference: Torso | Origin: VRP
CG_par1
# CG of the partial cone
CG_par1 = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)               # Frame of reference: Torso | Origin: Hemiellipsoid base
CG_par1
# MOI of the partial cone about the wide base
I_par1  = calc_inertia_ellcone(w_max, h_max, l_par, l_full, rho_par)  # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_parCG = parallelaxis(I_par1,CG_par1,m_par,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_par2 = CG_par1 + c(0,0,l_bmax)                                        # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")
m_end  = (1/12)*(pi*rho_back*w_leg*h_leg*l_end)
# CG of the end cone
CG_end1 = c(0,0,0.25*l_end)                               # Frame of reference: Torso | Origin: Base of the end cone
# MOI of the partial cone about the wide base
I_end1  = calc_inertia_ellcone(w_leg, h_leg, l_end, l_end, rho_back)     # Frame of reference: Torso | Origin: Base of the end cone
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_endCG = parallelaxis(I_end1,CG_end1,m_end,"A")                         # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_end2 = CG_end1 + c(0,0,(l_bmax + l_par))                              # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_endCG,-CG_end2,m_end,"CG")                    # Frame of reference: Torso | Origin: VRP
CG_par2
CG_end2
CG_ell2
m_par
m_end
m_ell
I_par_vrp
I_ell_vrp
I_ell1
I_ellCG
I_par1
I_parCG
I_par_vrp
I_end1
I_endCG
I_par_vrp
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")                 # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_end_vrp = parallelaxis(I_endCG,-CG_end2,m_end,"CG")                    # Frame of reference: Torso | Origin: VRP
I_par_vrp
I_end_vrp
CG_end2
CG_torso_vrp = (1/m_tot)*(m_ell*CG_ell2 + m_par*CG_par2 + m_end*CG_end2)
CG_torso_vrp = (1/m_true)*(m_ell*CG_ell2 + m_par*CG_par2 + m_end*CG_end2)
CG_torso_vrp
mass_prop$CG = t(VRP2object) %*% CG_torso_vrp                             # Frame of reference: VRP | Origin: VRP
start = c(0,0,0)
end = c(0,0,l_tot)
end = c(l_tot,0,0)
# ------------------------------- Adjust axis -------------------------------------
z_axis = end-start
temp_vec = c(0,1,0) # arbitrary vector as long as it's not the z-axis
x_axis = pracma::cross(z_axis,temp_vec/norm(temp_vec, type = "2"))
# doesn't matter where the x axis points as long as:1. we know what it is 2. it's orthogonal to z
# calculate the rotation matrix between VRP frame of reference and the object
VRP2object = calc_rot(z_axis,x_axis)
# ---------------------- Kroneckerdelta function ---------------------------
#' Kroneckerdelta function
#'
#' @param i  a scalar index (usually row of a matrix)
#' @param j  a scalar index (usually column of a matrix)
#'
#' @author Christina Harvey
#'
#' @return a scalar value. Returns 1 if i and j are equal otherwise returns 0
#'
#' @examples
#'
#'  # should return 1
#'  kronecker_delta(7,7)
#'
#'  # should return 0
#'  kronecker_delta(5,4)
#'
#' @export
#'
kronecker_delta <- function(i,j){
if (i == j) {
return(1)
}
else {
return(0)
}
}
# ---------------------- Rotation about the x axis ---------------------------
#' A 3x3 rotation matrix allowing rotation about the x-axis. Constructed using a cosine rotation matrix where the rotation angle in degrees
#' is measured counterclockwise allowing positive rotation under the right hand rule.
#'
#' @param angle a scalar representing the angle to rotate (degrees)
#'
#' @author Christina Harvey
#'
#' @return a 3x3 matrix representing the rotation about the x-axis by the given angle
#' @export
#'
#' @examples
#'
rotx <- function(angle){
R = matrix(0, nrow = 3, ncol = 3)
R[1,1] = 1
R[2,2] = pracma::cosd(angle)
R[3,3] = pracma::cosd(angle)
R[3,2] = pracma::sind(angle)
R[2,3] = -pracma::sind(angle)
return(R)
}
# ---------------------- Calculate a unit vector --------------------------
#' Determine the unit vector of any input vector
#'
#' @param vector any vector or array with only one dimension
#'
#' @author Christina Harvey
#'
#' @return the unit vector in the size of the input vector
#'
#' @examples
#'
#' output = calc_univec(c(2,6,5))
#' length_output = pracma::Norm(output) #should equal 1 if a unit vector
#'
#' @export
calc_univec <- function(vector){
unit_vector = vector/pracma::Norm(vector)
return(unit_vector)
}
# ---------------------- Calculate a rotation matrices ---------------------------
#' A 3x3 rotation matrix constructed by projecting the new axes onto the original system. Likely results in rotation about all axes.
#'
#' @param z_vector a 1x3 vector representing the direction for the desired z axis of the new frame of reference.
#' @param x_vector a 1x3 vector representing the direction for the desired x axis of the new frame of reference.
#'
#' @author Christina Harvey
#'
#' @return a 3x3 matrix representing the rotation matrix that transforms between VRP frame and object frame
#'
#' @export
#'
calc_rot <- function(z_vector, x_vector){
#CAUTION: incoming vectors must be in the structural frame at the VRP
#         x and z vectors must already be orthogonal axes
# ensure vectors are in unit form
unit_z_vector = calc_univec(z_vector)
unit_x_vector = calc_univec(x_vector)
#cross z with x to get the righthanded axis
y_vector = pracma::cross(unit_z_vector,unit_x_vector)
# ensure vectors are in unit form
unit_y_vector = calc_univec(y_vector)
# rotation matrix representing the rotated basis
VRP2object = rbind(unit_x_vector,unit_y_vector,unit_z_vector)
return(VRP2object)
}
# doesn't matter where the x axis points as long as:1. we know what it is 2. it's orthogonal to z
# calculate the rotation matrix between VRP frame of reference and the object
VRP2object = calc_rot(z_axis,x_axis)
VRP2object
mass_prop$CG = t(VRP2object) %*% CG_torso_vrp                             # Frame of reference: VRP | Origin: VRP
t(VRP2object) %*% CG_torso_vrp
# -------------- Sum data and adjust axes -------------------
I_torso_vrp  = I_ell_vrp+I_par_vrp+I_end_vrp
t(VRP2object) %*% I_torso_vrp %*% VRP2object
I_ell_vrp
I_par_vrp
I_end_vrp
I_par1
t(VRP2object) %*% I_torso_vrp %*% VRP2object
I_par1
VRP2object
I_ell1
w_max
h_max
l_max
l_bmax
# MOI about the base
I_ell1  = calc_inertia_ellipse(h_max/2, w_max/2, l_bmax, m_ell)   # Frame of reference: Torso | Origin: Hemiellipsoid base
I_ell1
I_par1
# -------------- Hemiellipsoid -------------------
# Determine the mass of the front
m_ell   = (1/6)*(pi*rho_ell*w_max*h_max*l_bmax)
# MOI about the base
I_ell1  = calc_inertia_ellipse(h_max/2, w_max/2, l_bmax, m_ell)   # Frame of reference: Torso | Origin: Hemiellipsoid base
# Define center of gravity wrt to I origin
CG_ell1 = c(0,0,-(3/8)*l_bmax)                                    # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the hemiellipsoid
I_ellCG = parallelaxis(I_ell1,CG_ell1,m_ell,"A")                  # Frame of reference: Torso | Origin: Hemiellipsoid CG
# Define center of gravity wrt to VRP origin
CG_ell2 = c(0,0,(5/8)*l_bmax)                                     # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_ell_vrp = parallelaxis(I_ellCG,-CG_ell2,m_ell,"CG")             # Frame of reference: Torso | Origin: VRP
# -------------- Partial elliptic cone -------------------
# mass as if the interior cone went to full length
m_full = (1/12)*(pi*rho_par*w_max*h_max*l_full)
# mass of the ghost part of the cone
m_cut  = (1/12)*(pi*rho_par*w_leg*h_leg*(l_full-l_par))
# mass of the partial cone
m_par  = m_full - m_cut
# CG as if the interior cone went to full length
CG_full = c(0,0,0.25*l_full)                                      # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the ghost part of the cone
CG_cut  = c(0,0,l_par+0.25*(l_full-l_par))                        # Frame of reference: Torso | Origin: Hemiellipsoid base
# CG of the partial cone
CG_par1 = (1/m_par)*(m_full*CG_full - m_cut*CG_cut)               # Frame of reference: Torso | Origin: Hemiellipsoid base
# MOI of the partial cone about the wide base
I_par1  = calc_inertia_ellcone(w_max, h_max, l_par, l_full, rho_par)  # Frame of reference: Torso | Origin: Hemiellipsoid base
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_parCG = parallelaxis(I_par1,CG_par1,m_par,"A")                      # Frame of reference: Torso | Origin: Partial Cone CG
# Define CG wrt to VRP origin
CG_par2 = CG_par1 + c(0,0,l_bmax)                                     # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_par_vrp = parallelaxis(I_parCG,-CG_par2,m_par,"CG")                 # Frame of reference: Torso | Origin: VRP
# -------------- Full elliptic cone -------------------
# mass of the end cone
m_end  = (1/12)*(pi*rho_back*w_leg*h_leg*l_end)
# CG of the end cone
CG_end1 = c(0,0,0.25*l_end)                                              # Frame of reference: Torso | Origin: Base of the end cone
# MOI of the partial cone about the wide base
I_end1  = calc_inertia_ellcone(w_leg, h_leg, l_end, l_end, rho_back)     # Frame of reference: Torso | Origin: Base of the end cone
# Adjust the moment of inertia to be about the center of gravity of the partial cone
I_endCG = parallelaxis(I_end1,CG_end1,m_end,"A")                         # Frame of reference: Torso | Origin: End Cone CG
# Define CG wrt to VRP origin
CG_end2 = CG_end1 + c(0,0,(l_bmax + l_par))                              # Frame of reference: Torso | Origin: VRP
# Adjust the MOI to be about the VRP
I_end_vrp = parallelaxis(I_endCG,-CG_end2,m_end,"CG")                    # Frame of reference: Torso | Origin: VRP
# -------------- Sum data and adjust axes -------------------
I_torso_vrp  = I_ell_vrp + I_par_vrp + I_end_vrp
CG_torso_vrp = (1/m_true)*(m_ell*CG_ell2 + m_par*CG_par2 + m_end*CG_end2)
t(VRP2object) %*% I_torso_vrp %*% VRP2object
I_end1
I_torso_vrp
I_ell1
h_max/2
w_max/2
l_bmax
t(VRP2object) %*% I_torso_vrp %*% VRP2object
usethis::use_package("pracma", type = "Imports", min_version = NULL)
