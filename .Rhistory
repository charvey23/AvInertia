## -----------------------------------------------------
specimens  = unique(dat_ind[,c("species","BirdID")])
# If there is a specimen that needs to be skipped remove it here
specimens  = specimens[-which(specimens$species == "tyt_alb" & specimens$BirdID == "18_1"),] # missing body data
specimens  = specimens[-which(specimens$species == "fal_per" & specimens$BirdID == "18_1"),] # missing body data
specimens  = specimens[-which(specimens$species == "ard_her" & specimens$BirdID == "20_317"),] # missing body data
specimens  = specimens[order(specimens$species),]
no_species = unique(specimens[,c("species")])
# --------------------- Initialize variables -----------------------
iter = 0
## ----------------------------------------------------
## --------- Iterate through each species -------------
## ----------------------------------------------------
#1:length(no_species)
for (m in 1:length(no_species)){
# ----------- Filter the data to the current species ---------
species_curr   = no_species[m]
specimens_curr = subset(specimens, species == species_curr)
# ---------- Acquire the appropriate feather data for the species --------------
# Inputs are adjusted to be in SI units, kg and m
# CAUTION: I only limit to the specific species - not specific birdID
tmp = subset(dat_feat, species == species_curr)
tmp_area   = tidyr::spread(aggregate(x = tmp$Area, by = list(tmp$Feather, tmp$Component), "mean"),"Group.2","x")
tmp_area   = tmp_area[,c("Group.1","distal vane","proximal vane")]
tmp_length = tidyr::spread(aggregate(x = tmp$Length, by = list(tmp$Feather, tmp$Component), "mean"),"Group.2","x")
tmp_length = tmp_length[,c("Group.1","calamus length","vane length","rachis width")]
tmp_angle  = tidyr::spread(aggregate(x = tmp$Angle, by = list(tmp$Feather, tmp$Component), "mean"),"Group.2","x")
tmp_angle  = tmp_angle[,c("Group.1","calamus length","vane length")]
dat_feat_curr = merge(tmp_area,tmp_length, by = "Group.1")
# computes the supplement angle to the interior angle between the calamus and vane
# assuming that the calamus is a positive angle and the vane is negative
# negative value indicates that the feather tip points towards the body
dat_feat_curr$vane_angle = 180 - (tmp_angle$"calamus length" - tmp_angle$"vane length")
# Need to account for the "flipped" view of feathers from the left wing
if(tmp$right_or_left[1] == "Left"){
dat_feat_curr$vane_angle = -dat_feat_curr$vane_angle
}
# Change all units from cm to m
dat_feat_curr$l_vane = dat_feat_curr$`vane length`*0.01
dat_feat_curr$l_cal  = dat_feat_curr$`calamus length`*0.01
dat_feat_curr$w_cal  = dat_feat_curr$`rachis width`*0.01
dat_feat_curr$w_vd   = 0.01*(dat_feat_curr$"distal vane")/(dat_feat_curr$"vane length")   # compute the average width of the distal vane
dat_feat_curr$w_vp   = 0.01*(dat_feat_curr$"proximal vane")/(dat_feat_curr$"vane length") # compute the average width of the proximal vane
# rename last column
names(dat_feat_curr)[names(dat_feat_curr) == "Group.1"] = "feather"
# create the alula row
row_alula = nrow(dat_feat_curr)+1
dat_feat_curr[row_alula, ]       = NA
dat_feat_curr$feather[row_alula] = "alula"
# ---- Save the bird id to scale if these are not from the same individual ----
dat_feat_ID = tmp$bird_id[1]
dat_feat_species = dat_feat_curr # save this
## --------------------------------------------------------------------
## ----------- Iterate through each specimen within a species ---------
## --------------------------------------------------------------------
for (k in 1:nrow(specimens_curr)){
# --------------------- Initialize variables -----------------------
all_data           = as.data.frame(matrix(0, nrow = 0, ncol = 7)) # overall data
column_names       = c("species","BirdID","TestID","FrameID","prop_type","component","value")
colnames(all_data) = column_names
iter = iter + 1
# ----------- Filter the data to the current individual ---------
birdid_curr   = specimens_curr$BirdID[k]
# skip body if required
if(dat_bird$use_body[which(dat_bird$BirdID == birdid_curr & dat_bird$species == species_curr)] == "N"){next}
dat_feat_curr = dat_feat_species # ensures that this doesn't get overwritten by looping
dat_bird_curr = subset(dat_bird, species == species_curr & BirdID == birdid_curr)
# ----------- Read in all the wing configuration data ------------
filename_wingconfigs = list.files(path = path_data_folder, pattern = paste(species_curr,birdid_curr,sep="_"))
dat_wing_curr        = read.csv(paste(path_data_folder,filename_wingconfigs,sep=""))
if(names(dat_wing_curr)[1] == "X"){
dat_wing_curr <- dat_wing_curr[,-1]
}
## --------------------------------------------------
## ------------------ Feather Info ------------------
## --------------------------------------------------
## ----- Update to the correct feather masses ---------
dat_feat_curr$m_f = NA
# save the combined alula feather masses
dat_feat_curr$m_f[row_alula]     = dat_bird_curr[1,"alular_mass_g"]
# save each individual feather mass
for (i in 1:(nrow(dat_feat_curr)-1)){
name_mass = paste(tolower(dat_feat_curr$feather[i]),"mass_g",sep = "_")
dat_feat_curr$m_f[i] = dat_bird_curr[1,name_mass]
# --- Scale the feather size as appropriate for this individual
if(dat_feat_ID != birdid_curr){
scaling_feat            = (dat_bird_curr[1,name_mass]/subset(dat_bird, species == species_curr & BirdID == dat_feat_ID)[1,name_mass])^(1/3)
dat_feat_curr$l_vane[i] = scaling_feat*dat_feat_curr$l_vane[i]
dat_feat_curr$l_cal[i]  = scaling_feat*dat_feat_curr$l_cal[i]
dat_feat_curr$w_cal[i]  = scaling_feat*dat_feat_curr$w_cal[i]
dat_feat_curr$w_vp[i]   = scaling_feat^2*dat_feat_curr$w_vp[i]
dat_feat_curr$w_vd[i]   = scaling_feat^2*dat_feat_curr$w_vd[i]
}
}
dat_feat_curr$species = species_curr
dat_feat_curr$BirdID = birdid_curr
# - Compute the I and CG of each feather - I origin is about feather CG and CG origin is start of feather, both in the feather FOR
feather_inertia <- compute_feat_inertia(dat_mat, dat_feat_curr, dat_bird_curr)
## --------------------------------------------------
## -------------------- Bone Info -------------------
## --------------------------------------------------
dat_bone_curr              = as.data.frame(matrix(nrow = 6, ncol = 5))
names(dat_bone_curr)       = c("bone", "bone_mass", "bone_len", "bone_out_rad", "bone_in_rad")
dat_bone_curr$bone         = c("Humerus","Ulna","Radius","Carpometacarpus","Ulnare", "Radiale")
dat_bone_curr$bone_mass    = c(dat_bird_curr$humerus_mass_g,dat_bird_curr$ulna_mass_g,dat_bird_curr$radius_mass_g,dat_bird_curr$cmc_mass_g,
dat_bird_curr$ulnare_mass_g,dat_bird_curr$radiale_mass_g)
dat_bone_curr$bone_len     = c(dat_bird_curr$humerus_length_mm,dat_bird_curr$ulna_length_mm,dat_bird_curr$radius_length_mm,dat_bird_curr$cmc_length_mm,
NA,NA)
dat_bone_curr$bone_out_rad = c(dat_bird_curr$humerus_diameter_mm,
dat_bird_curr$ulna_diameter_mm,
dat_bird_curr$radius_diameter_mm,
dat_bird_curr$cmc_diameter_mm,NA,NA)
dat_bone_curr$bone_out_rad = 0.5*dat_bone_curr$bone_out_rad
dat_bone_curr$bone_in_rad  = 0.78*dat_bone_curr$bone_out_rad # Ref. De Margerie (2005)
# --------------- Clean up wing 3D incoming data --------------------
# CAUTION:   The wing data has the origin at the RH humeral head Pt1
#            (for both left and right wings due to the aligning process).
#            It is critical that the data is given in the structural
#            frame of reference with the origin at the vehicle reference
#            point (VRP). VRP is assumed to be in the center of the body
#            on the y axis between the two humerus bones at the clavicle point
for (i in 12:44){
# x position - the sign has been verified - negative ensures that the shoulder is "behind" the clavicle origin
if (grepl("X",colnames(dat_wing_curr)[i],fixed=TRUE)){
dat_wing_curr[,i] = dat_wing_curr[,i] - (dat_bird_curr$x_loc_humeral_insert)
}
# y position - the sign has been verified
# CAUTION: this assumes the wings is on the right side of the bird for all calculations
if (grepl("Y",colnames(dat_wing_curr)[i],fixed=TRUE)){
dat_wing_curr[,i] = dat_wing_curr[,i] + (dat_bird_curr$y_loc_humeral_insert)
}
# z position - the sign has been verified + positive ensures that the shoulder is "below" the clavicle origin
if (grepl("Z",colnames(dat_wing_curr)[i],fixed=TRUE)){
dat_wing_curr[,i] = dat_wing_curr[,i] + (dat_bird_curr$z_loc_humeral_insert)
}
}
# Subset to only physically reasonable ranges
# Elbow can't go past the center line
row_keep      = which(dat_wing_curr$pt2_Y > 0 &
#Pt 3, 4, 6, 7 can't go past the edge of body Pt 12.
dat_wing_curr$pt3_Y > dat_wing_curr$pt12_Y & dat_wing_curr$pt4_Y > dat_wing_curr$pt12_Y &
dat_wing_curr$pt6_Y > dat_wing_curr$pt12_Y & dat_wing_curr$pt7_Y > dat_wing_curr$pt12_Y)
dat_wing_curr = dat_wing_curr[row_keep,]
# Need a blank data frame to save each iteration
mass_properties = as.data.frame(matrix(0, nrow = 0, ncol = 7)) # overall data
column_names = c("species","BirdID","TestID","FrameID","prop_type","component","value")
colnames(mass_properties) = column_names
# -------- Save the final input info used for this specimen -------
dat_id_curr = dat_wing_curr[1,c("species","BirdID","TestID","FrameID")]
# Compute the CG and I for the body without the wings
curr_torsotail_data = massprop_restbody(dat_id_curr, dat_bird_curr)
## --------------------------------------------------------------------------------
## ------------------ Iterate through all wing configurations ---------------------
## --------------------------------------------------------------------------------
for (ind_wing in 1:nrow(dat_wing_curr)){
# both data frames below should only be one row of input points
dat_pt_curr = dat_wing_curr[ind_wing,]
dat_id_curr = dat_pt_curr[,c("species","BirdID","TestID","FrameID")]
dat_id_curr$TestID = paste(dat_pt_curr$BirdID_FrameSpec, dat_id_curr$TestID, sep = "_")
# Initialize common pts
Pt1  = c(dat_pt_curr$pt1_X, dat_pt_curr$pt1_Y, dat_pt_curr$pt1_Z) # Shoulder
Pt2  = c(dat_pt_curr$pt2_X, dat_pt_curr$pt2_Y, dat_pt_curr$pt2_Z) # Elbow
Pt3  = c(dat_pt_curr$pt3_X, dat_pt_curr$pt3_Y, dat_pt_curr$pt3_Z) # Wrist
Pt4  = c(dat_pt_curr$pt4_X, dat_pt_curr$pt4_Y, dat_pt_curr$pt4_Z) # End of carpometacarpus
Pt6  = c(dat_pt_curr$pt6_X, dat_pt_curr$pt6_Y, dat_pt_curr$pt6_Z) # Leading edge in front of wrist
Pt8  = c(dat_pt_curr$pt8_X, dat_pt_curr$pt8_Y, dat_pt_curr$pt8_Z)    # Tip of most distal primary
Pt9  = c(dat_pt_curr$pt9_X, dat_pt_curr$pt9_Y, dat_pt_curr$pt9_Z)    # Tip of last primary to model as if on the end of the carpometacarpus
# if the first secondary goes into where body would be rotate the last secondary back outwards - use the shoulder to approximate the width of the body at this point
if(dat_pt_curr$pt10_Y < dat_pt_curr$pt1_Y){
dat_pt_curr$pt10_X = dat_pt_curr$pt2_X - sqrt((dat_pt_curr$pt10_Y-dat_pt_curr$pt2_Y)^2+
(dat_pt_curr$pt10_X-dat_pt_curr$pt2_X)^2-
((dat_pt_curr$pt1_Y + 0.005)-dat_pt_curr$pt2_Y)^2)
dat_pt_curr$pt10_Y = dat_pt_curr$pt1_Y + 0.005 # leave 5mm gap to properly distribute the feathers in this range
dat_wing_curr$pt10_Y[ind_wing] = dat_pt_curr$pt10_Y
dat_wing_curr$pt10_X[ind_wing] = dat_pt_curr$pt10_X
}
# if the last secondary goes into where body would be rotate the last secondary back outwards - use the shoulder to approximate the width of the body at this point
if(dat_pt_curr$pt11_Y < dat_pt_curr$pt1_Y){
dat_pt_curr$pt11_X = dat_pt_curr$pt2_X - sqrt((dat_pt_curr$pt11_Y-dat_pt_curr$pt2_Y)^2+
(dat_pt_curr$pt11_X-dat_pt_curr$pt2_X)^2-
(dat_pt_curr$pt1_Y-dat_pt_curr$pt2_Y)^2)
dat_pt_curr$pt11_Y = dat_pt_curr$pt1_Y
dat_wing_curr$pt11_Y[ind_wing] = dat_pt_curr$pt11_Y
dat_wing_curr$pt11_X[ind_wing] = dat_pt_curr$pt11_X
}
Pt10 = c(dat_pt_curr$pt10_X, dat_pt_curr$pt10_Y, dat_pt_curr$pt10_Z) # S1
Pt11 = c(dat_pt_curr$pt11_X, dat_pt_curr$pt11_Y, dat_pt_curr$pt11_Z) # Wing root trailing edge
Pt12 = c(dat_pt_curr$pt12_X, dat_pt_curr$pt12_Y, dat_pt_curr$pt12_Z) # Wing root leading edge
clean_pts = rbind(Pt1,Pt2,Pt3,Pt4,Pt6,Pt8,Pt9,Pt10,Pt11,Pt12)
# Compute the CG and I for the wing configuration
curr_wing_data      = massprop_birdwing(dat_id_curr, dat_bird_curr, dat_bone_curr, dat_feat_curr, dat_mat, clean_pts, feather_inertia)
# Combine the torso and wing outputs
curr_full_bird      = combine_inertialprop(curr_torsotail_data,curr_wing_data,curr_wing_data, symmetric=TRUE)
new_row1 = data.frame(species = dat_id_curr$species[1], BirdID = dat_id_curr$BirdID[1],TestID = dat_id_curr$TestID[1], FrameID = dat_id_curr$FrameID[1],
component = "wing", object = "S_proj", value = dat_pt_curr$S_proj)
all_data = rbind(all_data, curr_wing_data, curr_full_bird, new_row1)
} # end of the individual wing configuration loop
# for the sake of memory need to recast from long to wide format to save
all_data = reshape2::dcast(all_data, species + BirdID + TestID + FrameID ~ component + object, value.var="value")
filename_output = paste(path_dataout_folder,format(Sys.Date(), "%Y_%m_%d"),"_",species_curr,"_",birdid_curr,"_results.csv",sep="")
write.csv(all_data,filename_output)
# ---- save all the individual info that does not change with wing position -------
if (iter == 1){
dat_wing_all = dat_wing_curr        # wing specimen info
dat_feat_all = dat_feat_curr        # feather specimen info
dat_bird_all = dat_bird_curr        # entire body specimen info
dat_body_all = curr_torsotail_data  # CG and MOI from the torso, tail, head and neck for this individual
}else{
dat_wing_all = rbind(dat_wing_all,dat_wing_curr)
dat_feat_all = rbind(dat_feat_all,dat_feat_curr)
dat_bird_all = rbind(dat_bird_all,dat_bird_curr)
dat_body_all = rbind(dat_body_all,curr_torsotail_data)
}
remove(all_data)
} # end of the specimen loop
} # end of the species loop
# --------------------------------------------------
# --------------- Save combined data ---------------
# --------------------------------------------------
dat_wing_all$TestID = paste(dat_wing_all$BirdID_FrameSpec, dat_wing_all$TestID, sep = "_")
filename = paste(path_dataout_folder,format(Sys.Date(), "%Y_%m_%d"),"_allspecimen_winginfo.csv",sep="")
write.csv(dat_wing_all,filename)
filename = paste(path_dataout_folder,format(Sys.Date(), "%Y_%m_%d"),"_allspecimen_birdinfo.csv",sep="")
write.csv(dat_bird_all,filename)
filename = paste(path_dataout_folder,format(Sys.Date(), "%Y_%m_%d"),"_allspecimen_featherinfo.csv",sep="")
write.csv(dat_feat_all,filename)
filename = paste(path_dataout_folder,format(Sys.Date(), "%Y_%m_%d"),"_bodyCGandMOI_correctneck.csv",sep="")
write.csv(dat_body_all,filename)
# This script was written to analyse the data that is returned from the birdmoment package
## Load up necessary packages
library(phytools)
library(ape)
library(geiger)
library(MCMCglmm)
library(tidyverse)
library(effectsize) # needed for eta_squared calculation
library(pracma)
library(ggplot2)
library(dplyr)
# --------------------- Read in data -----------------------
# CAUTION: All incoming measurements must be in SI units; adjust as required
# UPDATE REQUIRED: Should probably move final run files into the bird moment folder
path_data_folder = "/Users/christinaharvey/Dropbox (University of Michigan)/Bird Mass Distribution/outputdata/"
filename_wing = list.files(path = path_data_folder, pattern = paste("allspecimen_winginfo"))
dat_wing      = read.csv(file = paste(path_data_folder,filename_wing,sep= ""))
dat_wing     = dat_wing[,-c(1)]
filename_feat = list.files(path = path_data_folder, pattern = paste("allspecimen_featherinfo"))
dat_feat      = read.csv(file = paste(path_data_folder,filename_feat,sep= ""))
dat_feat      = dat_feat[,-c(1,3:7)]
filename_bird = list.files(path = path_data_folder, pattern = paste("allspecimen_birdinfo"))
dat_bird      = read.csv(file = paste(path_data_folder,filename_bird,sep= ""))
names(dat_bird)[names(dat_bird) == "binomial.x"] = "binomial"
dat_bird     = dat_bird[,-c(1)]
for (i in 1:nrow(dat_bird)){
if(!dat_bird$extend_neck[i]){
dat_bird$neck_length[i] = 0
}
}
filename_body = list.files(path = path_data_folder, pattern = paste("bodyCGandMOI_correct"))
dat_body      = read.csv(file = paste(path_data_folder,filename_body,sep= ""))
dat_body      = reshape2::dcast(dat_body, species + BirdID + TestID + FrameID ~ component + object, value.var="value")
# Read in each individual result
filename_results = list.files(path = path_data_folder, pattern = paste("results"))
dat_results = read.csv(paste(path_data_folder,filename_results[1],sep=""))
for (i in 2:length(filename_results)){
dat_results = rbind(dat_results,read.csv(paste(path_data_folder,filename_results[i],sep="")))
}
# clean up environments
remove(filename_wing,filename_feat,filename_bird,filename_body,filename_results)
# -------------  Merge with all info -----------------
dat_final = merge(dat_results,dat_wing[,c("species","BirdID","TestID","FrameID","BirdID_FrameSpec","elbow","manus","pt1_X","pt1_Y","pt1_Z",
"pt6_X","pt6_Y","pt7_X","pt7_Y","pt8_X","pt8_Y","pt8_Z","pt9_X","pt9_Y","pt10_X","pt10_Y",
"pt11_X","pt11_Y","pt11_Z","pt12_X","pt12_Y","pt12_Z")], by = c("species","BirdID","TestID","FrameID"))
dat_final = merge(dat_final,dat_bird, by = c("species","BirdID"))
dat_final = merge(dat_final,dat_body[,-c(3,4)], by = c("species","BirdID"))
dat_final$full_length  = (dat_final$torsotail_length+dat_final$head_length+dat_final$neck_length)
dat_final$torso_length = dat_final$torsotail_length - dat_final$tail_length
dat_final$span         = 2*sqrt(dat_final$pt8_X^2+dat_final$pt8_Y^2+dat_final$pt8_Z^2)
dat_final$full_CGx_specific_orgBeak    = (dat_final$full_CGx-dat_final$head_length-dat_final$neck_length)/dat_final$full_length
dat_final$full_CGz_specific_orgDorsal  = (dat_final$full_CGz+dat_final$z_dist_to_veh_ref_point_cm)/dat_final$full_length
dat_final$shoulderx_specific_orgBeak   = (dat_final$pt1_X-dat_final$head_length-dat_final$neck_length)/dat_final$full_length
dat_final$shoulderz_specific_orgDorsal = (dat_final$pt1_Z+dat_final$z_dist_to_veh_ref_point_cm)/dat_final$full_length
dat_final$full_CGx_specific_orgShoulder = (dat_final$full_CGx-dat_final$pt1_X)/dat_final$full_length
dat_final$full_CGz_specific_orgShoulder = (dat_final$full_CGz-dat_final$pt1_Z)/dat_final$full_length
dat_final$BeakTipx_orgShoulder          = (dat_final$head_length+dat_final$neck_length+dat_final$pt1_X)/dat_final$full_length
dat_final$Centrez_orgShoulder           = (dat_final$pt1_Z)/dat_final$full_length
dat_final$TailTipx_orgShoulder          = (-dat_final$torsotail_length-dat_final$pt1_X)/dat_final$full_length
dat_final$MaxWidthx_orgShoulder         = (-dat_final$x_loc_of_body_max-dat_final$pt1_X)/dat_final$full_length
dat_final$Dorsalz_orgShoulder           = -(dat_final$z_dist_to_veh_ref_point_cm+dat_final$pt1_Z)/dat_final$full_length
dat_final$Ventralz_orgShoulder          = (dat_final$body_height_max-(dat_final$z_dist_to_veh_ref_point_cm+dat_final$pt1_Z))/dat_final$full_length
test <- aggregate(list(humerus_per = dat_final$humerus_length_mm/dat_final$span),  by=list(species = dat_final$species, BirdID = dat_final$BirdID), min)
dat_final$elbow_scaled = dat_final$elbow*0.001
dat_final$manus_scaled = dat_final$manus*0.001
### ---------------------------------------------------------------------------------------
### ------------- Compute extremes of the CG position due to shoulder motion --------------
### ---------------------------------------------------------------------------------------
angle_shoulder = 80
dat_final$shoulderCG_dist <- ((dat_final$wing_CGx-dat_final$pt1_X)^2+(dat_final$wing_CGy-dat_final$pt1_Y)^2+(dat_final$wing_CGz-dat_final$pt1_Z)^2)
tmp <- aggregate(list(max_wingCG = dat_final$shoulderCG_dist),
by=list(species = dat_final$species, BirdID = dat_final$BirdID), max)
shoulder_motion <- dat_final[which(dat_final$shoulderCG_dist %in% tmp$max_wingCG),c("species","BirdID","elbow","manus","wing_CGx","wing_CGy","wing_CGz","pt1_X","pt1_Y","pt1_Z",
"wing_m","full_m","full_CGx","full_CGy","full_CGz","full_length","head_length","neck_length")]
shoulder_motion$rest_m   = (shoulder_motion$full_m-2*shoulder_motion$wing_m)
shoulder_motion$rest_CGx = (shoulder_motion$full_m*shoulder_motion$full_CGx - 2*(shoulder_motion$wing_m*shoulder_motion$wing_CGx))/shoulder_motion$rest_m
shoulder_motion$rest_CGz = (shoulder_motion$full_m*shoulder_motion$full_CGz - 2*(shoulder_motion$wing_m*shoulder_motion$wing_CGz))/shoulder_motion$rest_m
# - Rotate the wing forward about the shoulder in the x-y plane
new_wing_CGx = (cosd(angle_shoulder)*(shoulder_motion$wing_CGx-shoulder_motion$pt1_X) + sind(angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_X
new_wing_CGy = (-sind(angle_shoulder)*(shoulder_motion$wing_CGx-shoulder_motion$pt1_X) + cosd(angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) +shoulder_motion$pt1_Y
shoulder_motion$forward_CGx          = (shoulder_motion$rest_m*shoulder_motion$rest_CGx + 2*shoulder_motion$wing_m*new_wing_CGx)/shoulder_motion$full_m
shoulder_motion$forward_CGx_specific = (shoulder_motion$forward_CGx-shoulder_motion$pt1_X)/shoulder_motion$full_length
# - Rotate the wing backwards about the shoulder in the x-y plane
new_wing_CGx = (cosd(-angle_shoulder)*(shoulder_motion$wing_CGx-shoulder_motion$pt1_X) + sind(-angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_X
new_wing_CGy = (-sind(-angle_shoulder)*(shoulder_motion$wing_CGx-shoulder_motion$pt1_X) + cosd(-angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_Y
shoulder_motion$backwards_CGx          = (shoulder_motion$rest_m*shoulder_motion$rest_CGx + 2*shoulder_motion$wing_m*new_wing_CGx)/shoulder_motion$full_m
shoulder_motion$backwards_CGx_specific = (shoulder_motion$backwards_CGx-shoulder_motion$pt1_X)/shoulder_motion$full_length
shoulder_motion$range_CGx = (shoulder_motion$forward_CGx-shoulder_motion$backwards_CGx)
shoulder_motion$range_CGx_specific = (shoulder_motion$forward_CGx-shoulder_motion$backwards_CGx)/(shoulder_motion$full_length)
# - Rotate the wing up about the shoulder in the y-z plane
new_wing_CGz = (cosd(angle_shoulder)*(shoulder_motion$wing_CGz-shoulder_motion$pt1_Z) - sind(angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_Z
new_wing_CGy = (sind(angle_shoulder)*(shoulder_motion$wing_CGz-shoulder_motion$pt1_Z) + cosd(angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_Y
shoulder_motion$upwards_CGz          = (shoulder_motion$rest_m*shoulder_motion$rest_CGz + 2*shoulder_motion$wing_m*new_wing_CGz)/shoulder_motion$full_m
shoulder_motion$upwards_CGz_specific = (shoulder_motion$upwards_CGz-shoulder_motion$pt1_Z)/shoulder_motion$full_length
# - Rotate the wing down about the shoulder in the y-z plane
new_wing_CGz = (cosd(-angle_shoulder)*(shoulder_motion$wing_CGz-shoulder_motion$pt1_Z) - sind(-angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_Z
new_wing_CGy = (sind(-angle_shoulder)*(shoulder_motion$wing_CGz-shoulder_motion$pt1_Z) + cosd(-angle_shoulder)*(shoulder_motion$wing_CGy-shoulder_motion$pt1_Y)) + shoulder_motion$pt1_Y
shoulder_motion$downwards_CGz          = (shoulder_motion$rest_m*shoulder_motion$rest_CGz + 2*shoulder_motion$wing_m*new_wing_CGz)/shoulder_motion$full_m
shoulder_motion$downwards_CGz_specific = (shoulder_motion$downwards_CGz-shoulder_motion$pt1_Z)/shoulder_motion$full_length
shoulder_motion$range_CGz = (shoulder_motion$downwards_CGz-shoulder_motion$upwards_CGz)
shoulder_motion$range_CGz_specific = shoulder_motion$range_CGz/(shoulder_motion$full_length)
### ---------------------------------------------------------------------------------------
### --------------------------- Compute summed quantities ---------------------------------
### ---------------------------------------------------------------------------------------
# Maximum projected wing area and maximum wing span
test       <- aggregate(list(S_proj_max = dat_final$wing_S_proj,
b_max = dat_final$span),  by=list(species = dat_final$species, BirdID = dat_final$BirdID), max)
dat_bird   <- merge(dat_bird,test, by = c("species","BirdID"))
dat_final  <- merge(dat_final,test, by = c("species","BirdID"))
dat_final$wing_CGy_specific              = (dat_final$wing_CGy)/(0.5*dat_final$b_max)
dat_final$wing_CGy_specific_orgShoulder  = (dat_final$wing_CGy-dat_final$pt1_Y)/(0.5*dat_final$b_max)
dat_final$wing_CGx_specific_orgBeak      = (dat_final$wing_CGx-dat_final$head_length-dat_final$neck_length)/(0.5*dat_final$b_max)
dat_final$wing_CGx_specific_orgShoulder  = (dat_final$wing_CGx-dat_final$pt1_X)/(0.5*dat_final$b_max)
dat_final$wing_CGz_specific              = dat_final$wing_CGz/(0.5*dat_final$b_max)
# pull out the maximum wing shapes
max_wing_prop <- aggregate(list(b_max = dat_final$span),  by=list(species = dat_final$species), max)
max_wing <- subset(dat_final[,c("species","pt6_X","pt6_Y","pt7_X","pt7_Y","pt8_X","pt8_Y","pt8_Z","pt9_X","pt9_Y","pt10_X","pt10_Y",
"pt11_X","pt11_Y","pt11_Z","pt12_X","pt12_Y","pt12_Z","span")], span %in% max_wing_prop$b_max)
max_wing$edge_X = max_wing$pt11_X
max_wing$edge_Y = 0
max_wing[,2:21] <- max_wing[,2:21]/(0.5*max_wing$span)
remove(max_wing_prop)
dat_final$full_Ixx_specific  = dat_final$full_Ixx/(dat_final$full_m*dat_final$b_max*dat_final$full_length)
dat_final$full_Iyy_specific  = dat_final$full_Iyy/(dat_final$full_m*dat_final$b_max*dat_final$full_length)
dat_final$full_Izz_specific  = dat_final$full_Izz/(dat_final$full_m*dat_final$b_max*dat_final$full_length)
dat_final$full_Ixz_specific  = dat_final$full_Ixz/(dat_final$full_m*dat_final$b_max*dat_final$full_length)
# Shoulder position specific and mass
test     <- aggregate(list(full_m = dat_final$full_m),  by=list(species = dat_final$species, BirdID = dat_final$BirdID), max)
dat_bird <- merge(dat_bird,test, by = c("species","BirdID"))
### ---------------------- Compute inertial metrics -------------------------
# uses scaling from:
# Alerstam, T., Rosén, M., Bäckman, J., Ericson, P. G., & Hellgren, O. (2007).
# Flight speeds among bird species: allometric and phylogenetic effects. PLoS Biol, 5(8), e197.
dat_final$prop_q_dot     <- (abs(dat_final$full_CGx-dat_final$pt1_X)*dat_final$S_proj_max*dat_final$full_m^0.24)/dat_final$full_Iyy
dat_final$prop_q_dot_nd  <- (abs(dat_final$full_CGx-dat_final$pt1_X)*dat_final$S_proj_max*dat_final$full_length^2)/dat_final$full_Iyy
dat_final$del_M_specific <- dat_final$prop_q_dot*dat_final$full_Iyy/(dat_final$full_m*dat_final$full_length)
dat_final$sachs_pred_Ixx <- dat_final$full_m*(sqrt((0.14*dat_final$wing_m/dat_final$full_m))*dat_final$span*0.5)^2
dat_final$pitch_div <- (dat_final$full_Izz - dat_final$full_Ixx)/dat_final$full_Iyy
dat_final$yaw_div   <- (dat_final$full_Iyy - dat_final$full_Ixx)/dat_final$full_Izz
## ---- Compute the regression coefficients for each species for each variable -------
no_specimens <- nrow(dat_bird)
dat_model_out        <- data.frame(matrix(nrow = no_specimens*8*2, ncol = 5))
names(dat_model_out) <- c("species","model_variable","elb","man","elbman")
varlist_sp       <- c("full_Ixx_specific","full_Iyy_specific","full_Izz_specific","full_Ixz_specific",
"full_CGx_specific_orgBeak","wing_CGy_specific","full_CGz_specific_orgDorsal","wing_CGx_specific_orgBeak")
short_varlist_sp <- c("Ixx_sp","Iyy_sp","Izz_sp","Ixz_sp","CGx_sp","CGy_sp","CGz_sp")
varlist_abs      <- c("full_Ixx","full_Iyy","full_Izz","full_Ixz",
"full_CGx","wing_CGy","full_CGz","wing_CGx")
short_varlist_abs<- c("Ixx","Iyy","Izz","Ixz","CGx","CGy","CGz", "CGx_wing")
dat_bird$species <- as.character(dat_bird$species)
success = TRUE
count = 1
for (i in 1:no_specimens){
# subset data to the current species
tmp = subset(dat_final, species == dat_bird$species[i] & BirdID == dat_bird$BirdID[i])
tmp$elbow_centered = tmp$elbow-mean(tmp$elbow)
tmp$manus_centered = tmp$manus-mean(tmp$manus)
for (m in 1:2){
if(m == 1){
varlist = varlist_abs
short_varlist = short_varlist_abs
} else{
varlist = varlist_sp
short_varlist = short_varlist_sp
}
# --------------- Fit models ------------------
# full models
models <- lapply(varlist, function(x) {lm(substitute(k ~ elbow_scaled*manus_scaled, list(k = as.name(x))), data = tmp)})
models_adj <- lapply(varlist, function(x) {lm(substitute(k*100 ~ elbow_centered*manus_centered, list(k = as.name(x))), data = tmp)})
CI_values      = lapply(models, confint)
coef_values    = lapply(models, coef)
# Compute the effect size
etap_values    = lapply(models_adj, function(x){eta_squared(car::Anova(x, type = 3))})
count2 = 1
for (j in 1:length(models)){
dat_model_out$species[count]        <- dat_bird$species[i]
dat_model_out$BirdID[count]         <- dat_bird$BirdID[i]
dat_model_out$model_variable[count] <- short_varlist[j]
dat_model_out$int[count]            <- coef_values[[j]]["(Intercept)"]
dat_model_out$elb[count]            <- coef_values[[j]]["elbow_scaled"]
dat_model_out$man[count]            <- coef_values[[j]]["manus_scaled"]
dat_model_out$r2[count]             <- summary(models[[j]])$r.squared
dat_model_out$elbman[count]         <- coef_values[[j]]["elbow_scaled:manus_scaled"]
dat_model_out$int_lb[count]         <- CI_values[[j]]["(Intercept)",1]
dat_model_out$elb_lb[count]         <- CI_values[[j]]["elbow_scaled",1]
dat_model_out$man_lb[count]         <- CI_values[[j]]["manus_scaled",1]
dat_model_out$elbman_lb[count]      <- CI_values[[j]]["elbow_scaled:manus_scaled",1]
dat_model_out$int_ub[count]         <- CI_values[[j]]["(Intercept)",2]
dat_model_out$elb_ub[count]         <- CI_values[[j]]["elbow_scaled",2]
dat_model_out$man_ub[count]         <- CI_values[[j]]["manus_scaled",2]
dat_model_out$elbman_ub[count]      <- CI_values[[j]]["elbow_scaled:manus_scaled",2]
# Compute the effect sizes
dat_model_out$elb_etap[count]        <- etap_values[[j]][1,2]
dat_model_out$man_etap[count]        <- etap_values[[j]][2,2]
dat_model_out$elbman_etap[count]     <- etap_values[[j]][3,2]
count = count + 1
}
}
}
tmp           = reshape2::melt(dat_model_out, id = c("species","BirdID","model_variable"))
dat_model_out = reshape2::dcast(tmp, species + BirdID ~ model_variable + variable, value.var="value")
# Include basic geometry effects
tmp       = aggregate(list(full_m = dat_bird$full_m),  by=list(species = dat_bird$species, binomial = dat_bird$binomial, BirdID = dat_bird$BirdID), mean)
dat_comp  = merge(tmp, dat_model_out, by = c("species","BirdID"))
dat_model_out  = merge(tmp, dat_model_out, by = c("species","BirdID"))
tmp       = aggregate(list(torsotail_length = dat_bird$torsotail_length),  by=list(species = dat_bird$species, BirdID = dat_bird$BirdID), mean)
dat_comp  = merge(dat_comp, tmp, by = c("species","BirdID"))
# Include other important factors
# Range of each component
test     <- aggregate(list(range_CGx = dat_final$full_CGx,
range_CGx_specific = dat_final$full_CGx_specific_orgBeak,
range_wing_CGy = dat_final$wing_CGy,
range_wing_CGy_specific = dat_final$wing_CGy_specific,
range_CGz = dat_final$full_CGz,
range_CGz_specific = dat_final$full_CGz_specific_orgDorsal,
range_Ixx = dat_final$full_Ixx,
range_Ixx_specific = dat_final$full_Ixx_specific,
range_Iyy = dat_final$full_Iyy,
range_Iyy_specific = dat_final$full_Iyy_specific,
range_Izz = dat_final$full_Izz,
range_Izz_specific = dat_final$full_Izz_specific),
by=list(species = dat_final$species, BirdID = dat_final$BirdID), FUN=function(x){max(x)-min(x)})
dat_comp <- merge(dat_comp,test, by = c("species","BirdID"))
# Include other important factors
# Range of each component
test     <- aggregate(list(mean_CGx_orgBeak      = dat_final$full_CGx-dat_final$head_length-dat_final$neck_length,
mean_CGz_orgDorsal    = dat_final$full_CGz+dat_final$z_dist_to_veh_ref_point_cm,
mean_CGx_orgShoulder  = dat_final$full_CGx - dat_final$pt1_X,
mean_CGz_orgShoulder  = dat_final$full_CGz - dat_final$pt1_Z,
mean_CGz_orgDorsal= dat_final$full_CGz+dat_final$z_dist_to_veh_ref_point_cm,
mean_wing_CGy     = dat_final$wing_CGy,
mean_CGx_specific_orgBeak = dat_final$full_CGx_specific_orgBeak,
mean_CGz_specific_orgDorsal = dat_final$full_CGz_specific_orgDorsal,
mean_CGx_specific_orgShoulder = dat_final$full_CGx_specific_orgShoulder,
mean_CGz_specific_orgShoulder = dat_final$full_CGz_specific_orgShoulder,
mean_wing_CGy_specific = dat_final$wing_CGy_specific,
mean_Ixx_specific = dat_final$full_Ixx_specific,
mean_Iyy_specific = dat_final$full_Iyy_specific,
mean_Izz_specific = dat_final$full_Izz_specific,
mean_Ixz_specific = dat_final$full_Ixz_specific,
mean_Ixx          = dat_final$full_Ixx,
mean_Iyy          = dat_final$full_Iyy,
mean_Izz          = dat_final$full_Izz,
mean_Ixz          = dat_final$full_Ixz,
full_length = dat_final$full_length),
by=list(species = dat_final$species, BirdID = dat_final$BirdID), mean)
dat_comp <- merge(dat_comp,test, by = c("species","BirdID"))
# Maximum values
test     <- aggregate(list(max_CGx_orgBeak       = dat_final$full_CGx-dat_final$head_length-dat_final$neck_length,
max_CGz_orgDorsal     = dat_final$full_CGz+dat_final$z_dist_to_veh_ref_point_cm,
max_CGx_specific      = dat_final$full_CGx_specific_orgBeak,
max_wing_CGy          = dat_final$wing_CGy,
max_wing_CGy_specific = dat_final$wing_CGy_specific,
max_CGz_specific      = dat_final$full_CGz_specific_orgDorsal,
max_Ixx               = dat_final$full_Ixx,
max_wing_Ixx          = dat_final$wing_Ixx,
sachs_pred_Ixx        = dat_final$sachs_pred_Ixx,
max_Ixx_specific      = dat_final$full_Ixx_specific,
max_Iyy               = dat_final$full_Iyy,
max_Iyy_specific      = dat_final$full_Iyy_specific,
max_Izz               = dat_final$full_Izz,
max_Izz_specific      = dat_final$full_Izz_specific,
max_Ixz_specific      = dat_final$full_Ixz_specific,
max_q                 = dat_final$prop_q_dot,
max_q_nd              = dat_final$prop_q_dot_nd,
max_wingspan          = dat_final$span,
max_length            = dat_final$full_length),
by=list(species = dat_final$species, BirdID = dat_final$BirdID), max)
dat_comp <- merge(dat_comp,test, by = c("species","BirdID"))
# Minimum values
test     <- aggregate(list(min_CGx_orgBeak       = dat_final$full_CGx-dat_final$head_length-dat_final$neck_length,
min_CGz_orgDorsal     = dat_final$full_CGz+dat_final$z_dist_to_veh_ref_point_cm,
min_CGx_specific      = dat_final$full_CGx_specific_orgBeak,
min_wing_CGy          = dat_final$wing_CGy,
min_wing_CGy_specific = dat_final$wing_CGy_specific,
min_CGz_specific      = dat_final$full_CGz_specific_orgDorsal,
min_wing_Ixx          = dat_final$wing_Ixx,
min_Ixx_specific      = dat_final$full_Ixx_specific,
min_Iyy               = dat_final$full_Iyy,
min_Iyy_specific      = dat_final$full_Iyy_specific,
min_Izz               = dat_final$full_Izz,
min_Izz_specific      = dat_final$full_Izz_specific,
min_Ixz_specific      = dat_final$full_Ixz_specific),  by=list(species = dat_final$species, BirdID = dat_final$BirdID), min)
dat_comp <- merge(dat_comp,test, by = c("species","BirdID"))
